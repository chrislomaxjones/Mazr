/*
	SpriteBatch.js
	SpriteBatch object
	---------
	Written on the 30/10/2014 by Chris Jones

	This file represents the SpriteBatch data structure represented in the Data
	Structures section of the design specification.

	The function SpriteBatch represents a function from which the SpriteBatch
	object can be instantiated. This will represent the spriteBatch data 
	structure.

	SpriteBatch controls the drawing of an array of sprites to a canvas through
	a canvas' drawing context. It maintains an array of sprites that are drawn
	one by one to the canvas in their correct position by drawing coloured
	rectangles. Once all of the rectangles are drawn then paths are created for
	each of the sprite's walls. This is encapsulated in a draw function

	A SpriteBatch object is maintained by a Maze object in order to draw all the
	sprites generated by a maze. It exposes its drawing functions so it draws
	to the canvas approximately 30 times a second.

	SpriteBatch has 3 attributes:
		- batch: An array, declared empty upon instantiation, that contains
		         the sprites that are to be drawn to the canvas. Sprites are
		         added in order relative to their z-index on the canvas. For
		         example, adding two sprites with exactly the same positions
		         will cause the last sprite added to be drawn on top of the
		         first sprite added.

		- canvasContext: A reference to the 2D drawing context of the cavnas
						 onto which the sprites will be drawn.

		- camera: Reference to the camera object with which the game is being
				  viewed.

	SpriteBatch has one method:
		- draw: This draws all of the sprites in batch to canvas serially 
				(one after another). All of the sprite's backgrounds are
				first drawn and then the walls are all drawn together on
				top. This ensures no sprites are drawn on top of the walls.
*/
function SpriteBatch(canvasContext, camera) {
	// Contains a batch of sprites to draw
	// Initialise as an empty array
	// As this is an attribute of the SpriteBatch object
	// it can be populated later
	this.batch = [];

	// Reference to canvasContext on which the batch is drawn
	// Note there is no defaulting code path for the canvasContext
	// This is because it would be meaningless for a spritebatch
	// to have a canvas drawing context defined itself
	if (canvasContext === undefined || canvasContext === null) {
		throw "Argument error. Improper canvas context specified.";
	} else {
		// Assign canvasContext parameter to canvasContext attribute
		this.canvasContext = canvasContext; 
	}

	// Reference to camera to which the sprites will be transformed
	// Note there is no defaulting code path for the camera
	// This is because it would be meaningless for a spritebatch 
	// to draw to its own camera
	if (camera === undefined || camera === null) {
		throw "Argument error. Improper camera specified.";
	} else {
		// Assign camera parameter to camera attribute
		this.camera = camera;
	}

	// draw function acts as method that handles the drawing of sprites in batch
	this.draw = function() {
		// Iterate through each sprite in the batch
		for (var i in this.batch) {
			// Check that the i'th sprite is located  
			// within the bounds of the camera 
			// This means computer resources aren't wasted rendering
			// a sprite that isn't going to be seen

			// Subtracting the camera's coordinate's from those of 
			// the sprite effectively moves the sprites with respect
			// to a stationary camera. This has the effect of the camera
			// moving and the sprites remaining stationary
			if ((this.batch[i].x - this.camera.x < this.camera.width) && 
				(this.batch[i].y - this.camera.y < this.camera.height)) {
				
				// Set the fillStyle of the canvas equal
				// to the colour of the sprite 
				this.canvasContext.fillStyle = this.batch[i].colour;

				// Draw a rectangle onto the canvas 
				// At the x and y coods of the sprite minus the camera's coods
				// The size of the rectangle should equal 
				// the TILE_SIZE constnant
				this.canvasContext.fillRect(
					this.batch[i].x - this.camera.x, 
					this.batch[i].y - this.camera.y, 
					TILE_SIZE,
					TILE_SIZE
				);
			}
		}

		// Set the colour of the walls to the constant WALL_COLOUR
		this.canvasContext.strokeStyle = WALL_COLOUR;
		// Set the width of the walls to constant TILE_SIZE divided by 16
		this.canvasContext.lineWidth = TILE_SIZE / 16;

		// Begin drawing the path
		this.canvasContext.beginPath();
		
		// Draw the walls
		for (var i in this.batch) {
			// Check that the i'th sprite is located  
			// within the bounds of the camera 
			// This means computer resources aren't wasted rendering
			// a sprite that isn't going to be seen

			// Subtracting the camera's coordinate's from those of 
			// the sprite effectively moves the sprites with respect
			// to a stationary camera. This has the effect of the camera
			// moving and the sprites remaining stationary
			if ((this.batch[i].x - this.camera.x < this.camera.width) && 
				(this.batch[i].y - this.camera.y < this.camera.height)) {

				// Check if there is a top / north wall and draw if there is
				if (this.batch[i].walls[0]) {
					// Move the starting point to the top left-hand corner of ith sprite
					this.canvasContext.moveTo(
						this.batch[i].x - this.camera.x, 
						this.batch[i].y - this.camera.y
					);

					// Draw a line to the top right-hand corner of ith sprite
		  			this.canvasContext.lineTo(
		  				this.batch[i].x - this.camera.x + TILE_SIZE,
		  				 this.batch[i].y - this.camera.y
		  			);
		  		}

		  		// Check if there is a right / east wall and draw if there is
		  		if (this.batch[i].walls[1]) {
		  			// Move to the top-right hand corner of ith sprite
		  			this.canvasContext.moveTo(
		  				this.batch[i].x - this.camera.x + TILE_SIZE, 
		  				this.batch[i].y - this.camera.y
		  			);

		  			// Draw a line to the bottom-right hand corner of ith sprite
		  			this.canvasContext.lineTo(
		  				this.batch[i].x - this.camera.x + TILE_SIZE, 
		  				this.batch[i].y - this.camera.y + TILE_SIZE
		  			);
		  		}

		  		// Check if there is a bottom / south wall and draw if there is
		  		if (this.batch[i].walls[2]) { 
		  			// Move to the bottom-right hand corner of ith sprite
		  			this.canvasContext.moveTo(
		  				this.batch[i].x - this.camera.x + TILE_SIZE, 
		  				this.batch[i].y - this.camera.y + TILE_SIZE
		  			);

		  			// Draw a line to the bottom-left hand corner of ith sprite
		  			this.canvasContext.lineTo(
		  				this.batch[i].x - this.camera.x, 
		  				this.batch[i].y - this.camera.y + TILE_SIZE
		  			);
		 	 	}

		  		// Check if there is a left / west wall and draw if there is
		  		if (this.batch[i].walls[3]) {
		  			// Move to the bottom-left hand corner of ith sprite
		  			this.canvasContext.moveTo(
		  				this.batch[i].x - this.camera.x, 
		  				this.batch[i].y - this.camera.y + TILE_SIZE
		  			);
		  			
		  			// Draw a line to the top-left hand corner of ith sprite
		  			this.canvasContext.lineTo(
		  				this.batch[i].x - this.camera.x, 
		  				this.batch[i].y - this.camera.y
		  			);
		  	  	}
			}
		}

		// Draw the walls to canvasContext with .stroke() function
		this.canvasContext.stroke();
	}
}











